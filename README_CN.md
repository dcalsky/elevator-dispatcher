
电梯调度系统
===

Demo: [http://static.noddl.me/elevator/](http://static.noddl.me/elevator/)

## 一、模型假设

- 电梯运行状态呈匀速垂直运动
- 电梯系统运行时无任何人为意外状况发生

## 二、基本设定

### (1) 电梯

- 五部电梯初始位置为**一楼**
- 电梯同时接受来自乘客与操作员(用户)的指令
- 电梯运行速度以及人数容量均可在配置文件(index.ts)中设置

### (2) 乘客

- 自动模式下，乘客由生成器生成，随机分布在1-20层，且目地楼层为除该层以外的其他楼层
- 手动模式下，乘客的位置以及目地楼层由操作员（用户）决定，但应符合实际规范
- 乘客随机出现的时间间隔可在配置文件(index.ts)中设置

### (3) 等待队列

- 每层楼都有各自的等待队列，且无人数限制

### (4) 模式切换

- 模式之间（手动与自动）的切换并不会中断电梯系统当前的运行，只会停止自动随机产生乘客

## 三、电梯 Elevator Class

电梯在空闲状态(如图1)时，接受来自调度器 (Dispatcher Class)发出的任务(Task Class)安排，考虑到模块分离，所以电梯不知道该任务的来源与详情。 


电梯接收任务后，会进入运行状态(如图2)，运行到达任务指定的楼层(Floor: Number)，并执行对应的回调函数(cb: Function)，以通知调度器完成到达该楼层的任务。 


随后根据调度器分配的乘客(Person Class)，电梯获取到当前所有乘客的目的地(dest: Number)，并在内部分配给自身任务(Tasks: Array<TaskType>)。

存在任务的电梯，会根据自身当前的运动方向，判断下一步的方向。采取**SCAN****算法**：电梯在最底层和最顶层之间连续往返运行，在运行过程中响应处在于电梯运行方向相同的各楼层上的请求。**在到达一层楼后，搜索在该方向以上的楼层是否还存在任务，如果有，继续朝着当前方向运行，直到无任务或到达顶层为止。**

电梯在到达每一层楼后，会执行以下行为：

1. 判断是否还有任务存在，如果没有进入空闲状态
2. 判断是否存在调度器发来的针对该楼层的回调函数，如果有，则执行
3. 判断是否有该层的任务，如果有且是内部任务，那么送出相关乘客并完成任务



## 四、调度器 Dispatcher Class

**调度器扮演的是衔接电梯与等待队列的作用。**

调度器首先会接受来自乘客生成器随机产生的乘客，并将他们分配给对应楼层的等待队列。随后创建新的任务通知(EmitFunction)电梯来接受该任务，并安置一个回调函数给接受了该任务的电梯进行触发，采用**抢占式算法**：

- 如果存在空闲电梯，那么寻找一步离任务目标楼层最近的电梯
- 如果所有电梯均无空闲，那么通知所有电梯来抢占该任务

一旦任务被任意一部电梯接受，那么回调函数cb会被执行。调度器会通知对应楼层的等待队列，并获取到该楼层所有有着共同需求的等待乘客。获取到乘客后，将乘客推送给接受了任务的电梯。



## 五、等待队列

等待队列的功能：接受调度器推送来的乘客、推送当前相关用户给调度器。

等待队列接受调度器推送来的所有乘客，并存储在乘客队列(Array<Person>)中，持有所有人的目标楼层列表。随后根据**或****(|)****算法**：

- 获取所有乘客的目标楼层相对当前楼层的方向列表(Array<DIRECTION>)
- 或运算方向列表得到等待队列状态(status: Object)，从而获取所有乘客向上与向下的意向

当调度器要求当前队列推送出乘客时，遍历当前乘客，获取出有相关方向意向的乘客并推送给调度器。 